-- Autogenerated on Fri May  8 09:41:59 2009 by mkaudit.pl

create table audit.dbxref (
    dbxref_id integer not null
  , db_id integer not null
  , version character varying(255) not null
  , description text
  , accession character varying(255) not null
) inherits (audit.audit);

create or replace function audit.audit_dbxref_insert_proc()
returns trigger
as $$
BEGIN
  raise exception 'Cannot insert directly into audit.dbxref. Use one of the child tables.';
END;
$$ language plpgsql;
create trigger dbxref_insert_tr before insert on audit.dbxref
    for each statement execute procedure audit.audit_dbxref_insert_proc();
grant select on audit.dbxref to chado_ro_role;
grant select, insert on audit.dbxref to chado_rw_role;
grant execute on function audit.audit_dbxref_insert_proc() to chado_rw_role;


create table audit.dbxref_insert (
    constraint dbxref_insert_ck check (type = 'INSERT')
) inherits (audit.dbxref);
alter table audit.dbxref_insert alter type set default 'INSERT';
grant select on audit.dbxref_insert to chado_ro_role;
grant select, insert on audit.dbxref_insert to chado_rw_role;

create or replace function audit.public_dbxref_insert_proc()
returns trigger
as $$
BEGIN
  insert into audit.dbxref_insert (
      dbxref_id, db_id, accession, version, description
  ) values (
      new.dbxref_id, new.db_id, new.accession, new.version, new.description
  );
  return new;
END;
$$ language plpgsql;
create trigger dbxref_audit_insert_tr after insert on public.dbxref
    for each row execute procedure audit.public_dbxref_insert_proc();
grant execute on function audit.public_dbxref_insert_proc() to chado_rw_role;


create table audit.dbxref_update (
    constraint dbxref_update_ck check (type = 'UPDATE')
  , old_description text
  , old_db_id integer not null
  , old_version character varying(255) not null
  , old_accession character varying(255) not null
) inherits (audit.dbxref);
alter table audit.dbxref_update alter type set default 'UPDATE';
grant select on audit.dbxref_update to chado_ro_role;
grant select, insert on audit.dbxref_update to chado_rw_role;

create or replace function audit.public_dbxref_update_proc()
returns trigger
as $$
BEGIN
  if old.dbxref_id <> new.dbxref_id or old.dbxref_id is null <> new.dbxref_id is null then
    raise exception 'If you want to change dbxref.dbxref_id (do you really?) then disable the audit trigger dbxref_audit_update_tr';
  end if;
  insert into audit.dbxref_update (
      dbxref_id, db_id, accession, version, description,
      old_db_id, old_accession, old_version, old_description
   ) values (
       new.dbxref_id, new.db_id, new.accession, new.version, new.description,
       old.db_id, old.accession, old.version, old.description
   );
  return new;
END;
$$ language plpgsql;
create trigger dbxref_audit_update_tr after update on public.dbxref
    for each row execute procedure audit.public_dbxref_update_proc();
grant execute on function audit.public_dbxref_update_proc() to chado_rw_role;


create table audit.dbxref_delete (
    constraint dbxref_delete_ck check (type = 'DELETE')
) inherits (audit.dbxref);
alter table audit.dbxref_delete alter type set default 'DELETE';
grant select on audit.dbxref_delete to chado_ro_role;
grant select, insert on audit.dbxref_delete to chado_rw_role;

create or replace function audit.public_dbxref_delete_proc()
returns trigger
as $$
BEGIN
  insert into audit.dbxref_delete (
      dbxref_id, db_id, accession, version, description
  ) values (
      old.dbxref_id, old.db_id, old.accession, old.version, old.description
  );
  return old;
END;
$$ language plpgsql;
create trigger dbxref_audit_delete_tr after delete on public.dbxref
    for each row execute procedure audit.public_dbxref_delete_proc();
grant execute on function audit.public_dbxref_delete_proc() to chado_rw_role;
