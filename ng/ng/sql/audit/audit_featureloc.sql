-- Autogenerated on Fri May  8 09:42:01 2009 by mkaudit.pl

create table audit.featureloc (
    feature_id integer not null
  , residue_info text
  , featureloc_id integer not null
  , fmax integer
  , is_fmin_partial boolean not null
  , fmin integer
  , phase integer
  , strand smallint
  , rank integer not null
  , is_fmax_partial boolean not null
  , locgroup integer not null
  , srcfeature_id integer
) inherits (audit.audit);

create or replace function audit.audit_featureloc_insert_proc()
returns trigger
as $$
BEGIN
  raise exception 'Cannot insert directly into audit.featureloc. Use one of the child tables.';
END;
$$ language plpgsql;
create trigger featureloc_insert_tr before insert on audit.featureloc
    for each statement execute procedure audit.audit_featureloc_insert_proc();
grant select on audit.featureloc to chado_ro_role;
grant select, insert on audit.featureloc to chado_rw_role;
grant execute on function audit.audit_featureloc_insert_proc() to chado_rw_role;


create table audit.featureloc_insert (
    constraint featureloc_insert_ck check (type = 'INSERT')
) inherits (audit.featureloc);
alter table audit.featureloc_insert alter type set default 'INSERT';
grant select on audit.featureloc_insert to chado_ro_role;
grant select, insert on audit.featureloc_insert to chado_rw_role;

create or replace function audit.public_featureloc_insert_proc()
returns trigger
as $$
BEGIN
  insert into audit.featureloc_insert (
      featureloc_id, feature_id, srcfeature_id, fmin, is_fmin_partial, fmax, is_fmax_partial, strand, phase, residue_info, locgroup, rank
  ) values (
      new.featureloc_id, new.feature_id, new.srcfeature_id, new.fmin, new.is_fmin_partial, new.fmax, new.is_fmax_partial, new.strand, new.phase, new.residue_info, new.locgroup, new.rank
  );
  return new;
END;
$$ language plpgsql;
create trigger featureloc_audit_insert_tr after insert on public.featureloc
    for each row execute procedure audit.public_featureloc_insert_proc();
grant execute on function audit.public_featureloc_insert_proc() to chado_rw_role;


create table audit.featureloc_update (
    constraint featureloc_update_ck check (type = 'UPDATE')
  , old_residue_info text
  , old_is_fmax_partial boolean not null
  , old_fmax integer
  , old_strand smallint
  , old_feature_id integer not null
  , old_srcfeature_id integer
  , old_is_fmin_partial boolean not null
  , old_phase integer
  , old_rank integer not null
  , old_fmin integer
  , old_locgroup integer not null
) inherits (audit.featureloc);
alter table audit.featureloc_update alter type set default 'UPDATE';
grant select on audit.featureloc_update to chado_ro_role;
grant select, insert on audit.featureloc_update to chado_rw_role;

create or replace function audit.public_featureloc_update_proc()
returns trigger
as $$
BEGIN
  if old.featureloc_id <> new.featureloc_id or old.featureloc_id is null <> new.featureloc_id is null then
    raise exception 'If you want to change featureloc.featureloc_id (do you really?) then disable the audit trigger featureloc_audit_update_tr';
  end if;
  insert into audit.featureloc_update (
      featureloc_id, feature_id, srcfeature_id, fmin, is_fmin_partial, fmax, is_fmax_partial, strand, phase, residue_info, locgroup, rank,
      old_feature_id, old_srcfeature_id, old_fmin, old_is_fmin_partial, old_fmax, old_is_fmax_partial, old_strand, old_phase, old_residue_info, old_locgroup, old_rank
   ) values (
       new.featureloc_id, new.feature_id, new.srcfeature_id, new.fmin, new.is_fmin_partial, new.fmax, new.is_fmax_partial, new.strand, new.phase, new.residue_info, new.locgroup, new.rank,
       old.feature_id, old.srcfeature_id, old.fmin, old.is_fmin_partial, old.fmax, old.is_fmax_partial, old.strand, old.phase, old.residue_info, old.locgroup, old.rank
   );
  return new;
END;
$$ language plpgsql;
create trigger featureloc_audit_update_tr after update on public.featureloc
    for each row execute procedure audit.public_featureloc_update_proc();
grant execute on function audit.public_featureloc_update_proc() to chado_rw_role;


create table audit.featureloc_delete (
    constraint featureloc_delete_ck check (type = 'DELETE')
) inherits (audit.featureloc);
alter table audit.featureloc_delete alter type set default 'DELETE';
grant select on audit.featureloc_delete to chado_ro_role;
grant select, insert on audit.featureloc_delete to chado_rw_role;

create or replace function audit.public_featureloc_delete_proc()
returns trigger
as $$
BEGIN
  insert into audit.featureloc_delete (
      featureloc_id, feature_id, srcfeature_id, fmin, is_fmin_partial, fmax, is_fmax_partial, strand, phase, residue_info, locgroup, rank
  ) values (
      old.featureloc_id, old.feature_id, old.srcfeature_id, old.fmin, old.is_fmin_partial, old.fmax, old.is_fmax_partial, old.strand, old.phase, old.residue_info, old.locgroup, old.rank
  );
  return old;
END;
$$ language plpgsql;
create trigger featureloc_audit_delete_tr after delete on public.featureloc
    for each row execute procedure audit.public_featureloc_delete_proc();
grant execute on function audit.public_featureloc_delete_proc() to chado_rw_role;
