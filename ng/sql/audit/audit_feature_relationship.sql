-- Autogenerated on Fri May  8 09:42:00 2009 by mkaudit.pl

create table audit.feature_relationship (
    feature_relationship_id integer not null
  , subject_id integer not null
  , value text
  , type_id integer not null
  , object_id integer not null
  , rank integer not null
) inherits (audit.audit);

create or replace function audit.audit_feature_relationship_insert_proc()
returns trigger
as $$
BEGIN
  raise exception 'Cannot insert directly into audit.feature_relationship. Use one of the child tables.';
END;
$$ language plpgsql;
create trigger feature_relationship_insert_tr before insert on audit.feature_relationship
    for each statement execute procedure audit.audit_feature_relationship_insert_proc();
grant select on audit.feature_relationship to chado_ro_role;
grant select, insert on audit.feature_relationship to chado_rw_role;
grant execute on function audit.audit_feature_relationship_insert_proc() to chado_rw_role;


create table audit.feature_relationship_insert (
    constraint feature_relationship_insert_ck check (type = 'INSERT')
) inherits (audit.feature_relationship);
alter table audit.feature_relationship_insert alter type set default 'INSERT';
grant select on audit.feature_relationship_insert to chado_ro_role;
grant select, insert on audit.feature_relationship_insert to chado_rw_role;

create or replace function audit.public_feature_relationship_insert_proc()
returns trigger
as $$
BEGIN
  insert into audit.feature_relationship_insert (
      feature_relationship_id, subject_id, object_id, type_id, value, rank
  ) values (
      new.feature_relationship_id, new.subject_id, new.object_id, new.type_id, new.value, new.rank
  );
  return new;
END;
$$ language plpgsql;
create trigger feature_relationship_audit_insert_tr after insert on public.feature_relationship
    for each row execute procedure audit.public_feature_relationship_insert_proc();
grant execute on function audit.public_feature_relationship_insert_proc() to chado_rw_role;


create table audit.feature_relationship_update (
    constraint feature_relationship_update_ck check (type = 'UPDATE')
  , old_subject_id integer not null
  , old_object_id integer not null
  , old_type_id integer not null
  , old_rank integer not null
  , old_value text
) inherits (audit.feature_relationship);
alter table audit.feature_relationship_update alter type set default 'UPDATE';
grant select on audit.feature_relationship_update to chado_ro_role;
grant select, insert on audit.feature_relationship_update to chado_rw_role;

create or replace function audit.public_feature_relationship_update_proc()
returns trigger
as $$
BEGIN
  if old.feature_relationship_id <> new.feature_relationship_id or old.feature_relationship_id is null <> new.feature_relationship_id is null then
    raise exception 'If you want to change feature_relationship.feature_relationship_id (do you really?) then disable the audit trigger feature_relationship_audit_update_tr';
  end if;
  insert into audit.feature_relationship_update (
      feature_relationship_id, subject_id, object_id, type_id, value, rank,
      old_subject_id, old_object_id, old_type_id, old_value, old_rank
   ) values (
       new.feature_relationship_id, new.subject_id, new.object_id, new.type_id, new.value, new.rank,
       old.subject_id, old.object_id, old.type_id, old.value, old.rank
   );
  return new;
END;
$$ language plpgsql;
create trigger feature_relationship_audit_update_tr after update on public.feature_relationship
    for each row execute procedure audit.public_feature_relationship_update_proc();
grant execute on function audit.public_feature_relationship_update_proc() to chado_rw_role;


create table audit.feature_relationship_delete (
    constraint feature_relationship_delete_ck check (type = 'DELETE')
) inherits (audit.feature_relationship);
alter table audit.feature_relationship_delete alter type set default 'DELETE';
grant select on audit.feature_relationship_delete to chado_ro_role;
grant select, insert on audit.feature_relationship_delete to chado_rw_role;

create or replace function audit.public_feature_relationship_delete_proc()
returns trigger
as $$
BEGIN
  insert into audit.feature_relationship_delete (
      feature_relationship_id, subject_id, object_id, type_id, value, rank
  ) values (
      old.feature_relationship_id, old.subject_id, old.object_id, old.type_id, old.value, old.rank
  );
  return old;
END;
$$ language plpgsql;
create trigger feature_relationship_audit_delete_tr after delete on public.feature_relationship
    for each row execute procedure audit.public_feature_relationship_delete_proc();
grant execute on function audit.public_feature_relationship_delete_proc() to chado_rw_role;
