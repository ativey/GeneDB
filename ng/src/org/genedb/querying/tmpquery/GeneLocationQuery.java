package org.genedb.querying.tmpquery;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;
import org.apache.lucene.index.Term;
import org.apache.lucene.search.BooleanClause.Occur;
import org.apache.lucene.search.BooleanQuery;

import org.apache.lucene.search.ConstantScoreRangeQuery;
import org.apache.lucene.search.Query;
import org.apache.lucene.search.TermQuery;
import org.genedb.querying.core.QueryClass;
import org.genedb.querying.core.QueryParam;

import org.springframework.validation.Errors;


@QueryClass(
        title="Transcripts by their type",
        shortDesc="Get a list of transcripts by type",
        longDesc=""
    )
public class GeneLocationQuery extends OrganismLuceneQuery {

	private transient Logger logger = Logger.getLogger(GeneLocationQuery.class);
	private static final long serialVersionUID = 215988209964782170L;


	@QueryParam(
            order=1,
            title="Name of feature"
    )
    private String topLevelFeatureName;


    @QueryParam(
            order=2,
            title="Min coordinate"
    )
    private int min;


    @QueryParam(
            order=3,
            title="Max coordinate"
    )
    private int max;
    
    @QueryParam(order = 4, title = "Include pseudogenes")
	private boolean pseudogenes;
    
    @Override
    public String getQueryDescription() {
    	return "Search for a gene by specifing its location on a chromosome, contig or other top level feature.";
    }

    @Override
    public String getQueryName() {
        return "Location";
    }
    

    // ------ Autogenerated code below here

    public void setTopLevelFeatureName(String topLevelFeatureName) {
    	logger.info("setting top level feature name " + topLevelFeatureName);
        this.topLevelFeatureName = topLevelFeatureName;
    }

    public String getTopLevelFeatureName() {
        return topLevelFeatureName;
    }


    public int getMin() {
        return min;
    }


    public int getMax() {
        return max;
    }


    public void setMin(int min) {
    	logger.info("setting min " + min);
        this.min = min;
    }

    public void setMax(int max) {
    	logger.info("setting max " + max);
        this.max = max;
    }
    
    public boolean isPseudogenes() {
		return pseudogenes;
	}

	public void setPseudogenes(boolean pseudogenes) {
		this.pseudogenes = pseudogenes;
	}


    @Override
    protected String[] getParamNames() {
        return new String[] {"topLevelFeatureName", "min", "max", "pseudogenes"};
    }
  

    @Override
    protected void extraValidation(Errors errors) {

        //validate dependent properties
        if (!errors.hasErrors()) {
            if (getMin() > getMax()) {
                errors.reject("start.greater.than.end");
            }
        }
    }
    
    @Override
    public Map<String, Object> prepareModelData() {
    	Map<String, Object> map = new HashMap<String, Object>();
    	map.put("topLevelFeatureName", topLevelFeatureName);
    	map.put("min", min);
    	map.put("max", max);
    	map.put("pseudogenes", pseudogenes);
    	logger.info("model : " + map);
    	return map;
    }

    
	@Override
	protected void getQueryTermsWithoutOrganisms(List<Query> queries) {
		
		BooleanQuery isInRegionAndIsOverlap = new BooleanQuery();
		
		TermQuery isInRegion = new TermQuery(new Term("chr", topLevelFeatureName));
		
		BooleanQuery spansBothSides = new BooleanQuery();
		ConstantScoreRangeQuery startLowerThanRequested =  new ConstantScoreRangeQuery("start", null, String.format("%09d", min), true, true);
		ConstantScoreRangeQuery endHigherThanRequested =  new ConstantScoreRangeQuery("stop",  String.format("%09d", max), null, true, true);
		
		spansBothSides.add(startLowerThanRequested, Occur.MUST);
		spansBothSides.add(endHigherThanRequested, Occur.MUST);
		
		BooleanQuery isInsideRange = new BooleanQuery();
		
		// numeric_start >= start && numeric_end <= end
		ConstantScoreRangeQuery startQuery = new ConstantScoreRangeQuery("start", String.format("%09d", min), String.format("%09d", max), true, true);
		ConstantScoreRangeQuery endQuery = new ConstantScoreRangeQuery("stop", String.format("%09d", min), String.format("%09d", max), true, true);
		
		isInsideRange.add(startQuery, Occur.SHOULD);
		isInsideRange.add(endQuery, Occur.SHOULD);
		
		BooleanQuery isOverlap = new BooleanQuery();
		isOverlap.add(spansBothSides, Occur.SHOULD);
		isOverlap.add(isInsideRange, Occur.SHOULD);
		
		isInRegionAndIsOverlap.add(isInRegion, Occur.MUST);
		isInRegionAndIsOverlap.add(isOverlap, Occur.MUST);
		
		queries.add(isInRegionAndIsOverlap);
		
		if (pseudogenes) {
			queries.add(productiveTranscriptQuery);
		} else {
			queries.add(mRNAQuery);
		}
		
	}

	@Override
	protected String getluceneIndexName() {
		return "org.gmod.schema.mapped.Feature";
	}
	
}
