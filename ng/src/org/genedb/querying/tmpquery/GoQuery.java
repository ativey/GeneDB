package org.genedb.querying.tmpquery;

import org.genedb.db.taxon.TaxonNode;
import org.genedb.querying.core.QueryClass;
import org.genedb.querying.core.QueryParam;

import org.apache.lucene.index.Term;
import org.apache.lucene.search.BooleanQuery;
import org.apache.lucene.search.PhraseQuery;
import org.apache.lucene.search.TermQuery;
import org.apache.lucene.search.WildcardQuery;
import org.apache.lucene.search.BooleanClause.Occur;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@QueryClass(
        title="Coding and pseudogenes by protein length",
        shortDesc="Get a list of transcripts ",
        longDesc=""
    )
public class GoQuery extends OrganismLuceneQuery {

    @QueryParam(
            order=1,
            title="The search string"
    )
    private String search = "";

    @Override
    public String getQueryDescription() {
    	return "Search for GO terms.";
    }

    @Override
    protected String getluceneIndexName() {
        return "org.gmod.schema.mapped.Feature";
    }

    @Override
    public String getQueryName() {
        return "GO";
    }

    @Override
    protected void getQueryTermsWithoutOrganisms(List<org.apache.lucene.search.Query> queries) {
        String tokens[] = search.trim().split("\\s");
        BooleanQuery bq = new BooleanQuery();

        if (tokens.length > 1) {
            PhraseQuery pq = new PhraseQuery();
            for (String token : tokens) {
                pq.add(new Term("go", token));
            }
            bq.add(pq, Occur.SHOULD);


        } else {
            String searchTerm = search.toLowerCase();

            //Strip out the go
            if (searchTerm!= null && searchTerm.startsWith("go:")){
                searchTerm = searchTerm.substring(3);
            }
            if (search.indexOf('*') == -1) {
                bq.add(new TermQuery(new Term("go",searchTerm)), Occur.SHOULD);
            } else {
                bq.add(new WildcardQuery(new Term("go", searchTerm)), Occur.SHOULD);
            }
        }

        queries.add(bq);
    }

    // ------ Autogenerated code below here

    public void setSearch(String search) {
        this.search = search;
    }

    public String getSearch() {
        return search;
    }

    @Override
    protected String[] getParamNames() {
        return new String[] {"search"};
    }
    
//    @Override
//    public Map<String, Object> prepareModelData() {
//    	List<String> taxonNames = new ArrayList<String>();
//    	for (TaxonNode t : taxons.getNodes()) {
//    		taxonNames.add(t.getLabel());
//    	}
//    	Map<String, Object> m = new HashMap<String,Object>();
//    	m.put("taxonNames", taxonNames);
//    	return Collections.emptyMap();
//    }

}
